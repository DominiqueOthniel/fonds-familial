const { app, BrowserWindow, ipcMain } = require("electron");
const path = require("path");
const bcrypt = require("bcryptjs");
const Database = require("better-sqlite3");
const dbManager = require("../../db-manager");

const db = new Database(path.join(__dirname, "tontine.db"));

// Création des tables si elles n'existent pas
db.exec(`
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    role TEXT NOT NULL CHECK(role IN ('admin', 'adjoint'))
  );

  CREATE TABLE IF NOT EXISTS membres (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    telephone TEXT NOT NULL,
    profession TEXT NOT NULL,
    ville TEXT NOT NULL,
    dateNaissance TEXT NOT NULL,
    caution TEXT NOT NULL
  );

  CREATE TABLE IF NOT EXISTS mouvements (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    membreId INTEGER NOT NULL,
    type TEXT NOT NULL CHECK(type IN ('épargne', 'crédit', 'caution')),
    montant REAL NOT NULL,
    motif TEXT,
    date TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(membreId) REFERENCES membres(id)
  );
`);

// Initialisation des utilisateurs si pas encore dans la table
const countUsers = db
  .prepare("SELECT COUNT(*) as count FROM users")
  .get().count;
if (countUsers === 0) {
  const hashAdmin = bcrypt.hashSync("admin1234", 10);
  const hashAdjoint = bcrypt.hashSync("adjoint1234", 10);

  const insertUser = db.prepare(
    "INSERT INTO users (email, password, role) VALUES (?, ?, ?)"
  );
  insertUser.run("admin@tontine.com", hashAdmin, "admin");
  insertUser.run("adjoint@tontine.com", hashAdjoint, "adjoint");
  console.log("Utilisateurs admin et adjoint créés");
}

let mainWindow;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 900,
    height: 700,
    webPreferences: {
      preload: path.join(__dirname, "preload.js"),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // 1) Toujours afficher d'abord login.html
  mainWindow.loadFile(path.join(__dirname, "login.html"));

  // 2) On attend que la page soit prête avant d'afficher la fenêtre
  mainWindow.once("ready-to-show", () => {
    mainWindow.show();
  });

  // Supprimer cette partie qui charge React directement
  /* if (process.env.NODE_ENV === 'development') {
    // En développement, charger le serveur Vite
    mainWindow.loadURL('http://localhost:5173');
  } else {
    // En production, charger l'interface compilée
    mainWindow.loadFile(path.join(__dirname, 'build', 'index.html'));
  } */
}

app.whenReady().then(createWindow);

app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) createWindow();
});

app.on("window-all-closed", () => {
  if (process.platform !== "darwin") app.quit();
});

// IPC handlers

ipcMain.handle("load-react-app", () => {
  try {
    if (process.env.NODE_ENV === "development") {
      mainWindow.loadURL("http://localhost:5173");
    } else {
      mainWindow.loadFile(path.join(__dirname, "build", "index.html"));
    }
    return { success: true };
  } catch (error) {
    console.error("Erreur lors du chargement de l'app React:", error);
    return { success: false, message: error.message };
  }
});

ipcMain.handle("login", async (_event, { email, password }) => {
  try {
    const stmt = db.prepare("SELECT * FROM users WHERE email = ?");
    const user = stmt.get(email);

    if (!user) {
      return { success: false, message: "Utilisateur non trouvé" };
    }
    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) {
      return { success: false, message: "Mot de passe incorrect" };
    }

    // Si OK, on recharge la fenêtre sur React
    if (process.env.NODE_ENV === "development") {
      mainWindow.loadURL("http://localhost:5173");
    } else {
      mainWindow.loadFile(path.join(__dirname, "build", "index.html"));
    }

    return { success: true, role: user.role };
  } catch (err) {
    console.error("Erreur login :", err);
    return { success: false, message: "Erreur serveur" };
  }
});

/* ipcMain.handle("ajouter-membre", (_event, membre) => {
  try {
    const { nom, telephone, profession, ville, dateNaissance, caution } =
      membre;
    const stmt = db.prepare(`
      INSERT INTO membres (nom, telephone, profession, ville, dateNaissance, caution)
      VALUES (?, ?, ?, ?, ?, ?)
    `);
    const info = stmt.run(
      nom,
      telephone,
      profession,
      ville,
      dateNaissance,
      caution
    );
    return { success: true, id: info.lastInsertRowid };
  } catch (err) {
    console.error("Erreur ajouter-membre:", err);
    throw err;
  }
});

ipcMain.handle("get-membres", () => {
  try {
    const stmt = db.prepare("SELECT * FROM membres ORDER BY nom ASC");
    return stmt.all();
  } catch (err) {
    console.error("Erreur get-membres:", err);
    throw err;
  }
});

ipcMain.handle(
  "modifier-membre",
  (_, id, nom, telephone, profession, ville, dateNaissance, caution) => {
    return dbManager.modifierMembre(
      id,
      nom,
      telephone,
      profession,
      ville,
      dateNaissance,
      caution
    );
  }
);

ipcMain.handle("supprimer-membre", (_event, id) => {
  try {
    const stmt = db.prepare("DELETE FROM membres WHERE id = ?");
    const info = stmt.run(id);
    return { success: info.changes > 0 };
  } catch (err) {
    console.error("Erreur supprimer-membre:", err);
    throw err;
  }
});

// Gestion mouvements (comptes)
ipcMain.handle("get-mouvements", () => {
  try {
    const stmt = db.prepare(`
      SELECT m.id, m.membreId, mem.nom as membreNom, m.type, m.montant, m.motif, m.date
      FROM mouvements m
      JOIN membres mem ON m.membreId = mem.id
      ORDER BY m.date DESC
    `);
    return stmt.all();
  } catch (err) {
    console.error("Erreur get-mouvements:", err);
    throw err;
  }
});

ipcMain.handle("ajouter-mouvement", (_event, mouvement) => {
  try {
    if (
      !mouvement ||
      !mouvement.membreId ||
      !mouvement.type ||
      !mouvement.montant
    ) {
      throw new Error("Champs requis manquants pour le mouvement");
    }

    const stmt = db.prepare(`
      INSERT INTO mouvements (membreId, type, montant, date)
      VALUES (?, ?, ?, ?)
    `);
    const info = stmt.run(
      mouvement.membreId,
      mouvement.type,
      mouvement.montant,
      mouvement.motif || null
    );
    return { success: true, id: info.lastInsertRowid };
  } catch (err) {
    console.error("Erreur ajouter-mouvement:", err);
    throw err;
  }
});

ipcMain.handle("get-soldes", () => {
  try {
    const stmt = db.prepare(`
      SELECT membreId, type, SUM(montant) as solde
      FROM mouvements
      GROUP BY membreId, type
    `);
    const soldes = stmt.all();
    return soldes; // [{membreId: 1, type: 'caution', solde: 30000}, ...]
  } catch (error) {
    console.error("Erreur dans get-soldes :", error);
    throw error;
  }
});

// AJOUTER SOLDE CAISSE
ipcMain.handle(
  "ajouterCaisse",
  (_event, type, categorie, montant, description = "") => {
    const date = new Date().toISOString();
    const stmt = db.prepare(
      "INSERT INTO caisse (date, type, categorie, montant, description) VALUES (?, ?, ?, ?, ?)"
    );
    stmt.run(date, type, categorie, montant, description);
    return { success: true };
  }
);

// GET SOLDE CAISSE
ipcMain.handle("getSoldeCaisse", () => {
  const totalEntree =
    db
      .prepare("SELECT SUM(montant) as total FROM caisse WHERE type = 'entree'")
      .get().total || 0;
  const totalSortie =
    db
      .prepare("SELECT SUM(montant) as total FROM caisse WHERE type = 'sortie'")
      .get().total || 0;
  return totalEntree - totalSortie;
});

// GET HISTORIQUE
ipcMain.handle("getHistoriqueCaisse", () => {
  return db.prepare("SELECT * FROM caisse ORDER BY date DESC").all();
});

// REMBOURSER CREDIT
ipcMain.handle("rembourserCredit", (event, creditId, montantPaye) => {
  const credit = db.prepare("SELECT * FROM credits WHERE id = ?").get(creditId);
  if (!credit) return { success: false, message: "Crédit introuvable" };

  const resteAvant = credit.reste;
  const nouveauReste = resteAvant - montantPaye;
  const statut = nouveauReste <= 0 ? "remboursé" : credit.statut;

  // Mise à jour crédit
  db.prepare(
    `UPDATE credits SET reste = ?, statut = ?, date_remboursement = ? WHERE id = ?`
  ).run(
    nouveauReste,
    statut,
    nouveauReste <= 0 ? new Date().toISOString() : null,
    creditId
  );

  // Ajout remboursement
  db.prepare(
    `INSERT INTO remboursements (id_credit, montant, date) VALUES (?, ?, ?)`
  ).run(creditId, montantPaye, new Date().toISOString());

  // Ajouter l'intérêt partiel dans la caisse (exemple simple)
  // Calculer part intérêt = 20% du montant total du crédit, réparti proportionnellement au montant payé
  const interetTotal = credit.montant * 0.2;
  const interetPartiel = (montantPaye / credit.montant) * interetTotal;

  db.prepare(
    `INSERT INTO caisse (date, type, categorie, montant, description) VALUES (?, ?, ?, ?, ?)`
  ).run(
    new Date().toISOString(),
    "entree",
    "interet",
    interetPartiel,
    `Remboursement partiel crédit #${creditId}`
  );

  return { success: true };
});

ipcMain.handle("getMouvementsCaisse", () => {
  const stmt = db.prepare("SELECT * FROM mouvements ORDER BY date DESC");
  return stmt.all(); // Pas besoin d'async ni de Promise ici
});

ipcMain.handle("get-credits", () => {
  try {
    const stmt = db.prepare(`
      SELECT c.id, m.nom, c.montant_initial, c.montant_a_rembourser, c.reste, c.date_accord, c.date_expiration, c.statut
      FROM credits c
      JOIN membres m ON c.id_membre = m.id
      ORDER BY c.date_accord DESC
    `);
    return stmt.all();
  } catch (err) {
    console.error("Erreur get-credits:", err);
    throw err;
  }
});

ipcMain.handle("get-remboursements", () => {
  try {
    const stmt = db.prepare(`
      SELECT r.id, r.id_credit, r.montant, r.date, m.nom
      FROM remboursements r
      JOIN credits c ON r.id_credit = c.id
      JOIN membres m ON c.id_membre = m.id
      ORDER BY r.date DESC
    `);
    return stmt.all();
  } catch (err) {
    console.error("Erreur get-remboursements:", err);
    throw err;
  }
});

ipcMain.handle("accorder-credit", (_event, data) => {
  try {
    const { id_membre, montant, montant_a_rembourser, date_expiration } = data;

    const montantARembourser = Math.ceil(montant * 1.2);
    const dateAccord = new Date().toISOString().split("T")[0];

    // Insérer le crédit dans la table
    const stmt = db.prepare(`
      INSERT INTO credits (id_membre, montant_initial, montant_a_rembourser, reste, date_accord, date_expiration, statut)
      VALUES (?, ?, ?, ?, ?, ?, 'actif')
    `);
    stmt.run(
      id_membre,
      montant,
      montant_a_rembourser,
      montant_a_rembourser,
      dateAccord,
      date_expiration
    );

    // Enregistrement dans mouvements (optionnel)
    db.prepare(
      `
      INSERT INTO mouvements (membreId, type, montant, motif, date)
      VALUES (?, 'credit', ?, 'Accord de prêt', ?)
    `
    ).run(id_membre, montant, dateAccord);

    // Mise à jour du solde dans comptes (si tu gères ça)
    db.prepare(
      `
      UPDATE comptes SET solde = solde + ?
      WHERE id_membre = ? AND type = 'credit'
    `
    ).run(montant, id_membre);

    return { success: true };
  } catch (error) {
    console.error("Erreur accorder-credit:", error);
    return { success: false, message: error.message };
  }
});
 */
// Autres handlers si besoin ...
